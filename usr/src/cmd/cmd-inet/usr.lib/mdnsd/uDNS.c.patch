# illumos revision
--- usr/src/contrib/mDNSResponder/mDNSCore/uDNS.c	2017-07-24 09:23:31.000000000 -0500
+++ usr/src/cmd/cmd-inet/usr.lib/mdnsd/uDNS.c	2017-07-24 09:23:49.000000000 -0500
@@ -131,8 +131,6 @@ mDNSexport DNSServer *mDNS_AddDNSServer(
         NumUnicastDNSServers, addr, d->c, interface, serviceID, scoped, resGroupID, reqA ? "True" : "False", reqAAAA ? "True" : "False",
         cellIntf ? "True" : "False", reqDO ? "True" : "False");
 
-    mDNS_CheckLock(m);
-
     while (*p)  // Check if we already have this {interface,address,port,domain} tuple registered + reqA/reqAAAA bits
     {
         if ((*p)->scoped == scoped && (*p)->interface == interface && (*p)->serviceID == serviceID && (*p)->teststate != DNSServer_Disabled &&
@@ -626,7 +624,10 @@ mDNSlocal mStatus uDNS_SendNATMsg(mDNS *
             req.reservedMapOp[1] = 0;
             req.reservedMapOp[2] = 0;
 
-            req.intPort = info->Protocol ? info->IntPort : DiscardPort;
+	    if (info->Protocol)
+                req.intPort = info->IntPort;
+	    else
+                req.intPort = DiscardPort;
             req.extPort = info->RequestedPort;
 
             // Since we only support IPv4, even if using the all-zeros address, map it, so
@@ -1853,7 +1854,10 @@ mDNSlocal void GetZoneData_QuestionCallb
         if (question->ThisQInterval != -1)
             LogMsg("GetZoneData_QuestionCallback: Question %##s (%s) ThisQInterval %d not -1", question->qname.c, DNSTypeName(question->qtype), question->ThisQInterval);
         zd->Addr.type  = mDNSAddrType_IPv4;
-        zd->Addr.ip.v4 = (answer->rdlength == 4) ? answer->rdata->u.ipv4 : zerov4Addr;
+	if (answer->rdlength == 4)
+            zd->Addr.ip.v4 = answer->rdata->u.ipv4;
+	else
+            zd->Addr.ip.v4 = zerov4Addr;
         // In order to simulate firewalls blocking our outgoing TCP connections, returning immediate ICMP errors or TCP resets,
         // the code below will make us try to connect to loopback, resulting in an immediate "port unreachable" failure.
         // This helps us test to make sure we handle this case gracefully
@@ -2661,6 +2665,7 @@ mDNSexport void mDNS_RemoveDynDNSHostNam
 mDNSexport void mDNS_SetPrimaryInterfaceInfo(mDNS *m, const mDNSAddr *v4addr, const mDNSAddr *v6addr, const mDNSAddr *router)
 {
     mDNSBool v4Changed, v6Changed, RouterChanged;
+    mDNSv6Addr v6;
 
     if (m->mDNS_busy != m->mDNS_reentrancy)
         LogMsg("mDNS_SetPrimaryInterfaceInfo: mDNS_busy (%ld) != mDNS_reentrancy (%ld)", m->mDNS_busy, m->mDNS_reentrancy);
@@ -2672,7 +2677,11 @@ mDNSexport void mDNS_SetPrimaryInterface
     mDNS_Lock(m);
 
     v4Changed     = !mDNSSameIPv4Address(m->AdvertisedV4.ip.v4, v4addr ? v4addr->ip.v4 : zerov4Addr);
-    v6Changed     = !mDNSSameIPv6Address(m->AdvertisedV6.ip.v6, v6addr ? v6addr->ip.v6 : zerov6Addr);
+    if (v6addr)
+	v6 = v6addr->ip.v6;
+    else
+	v6 = zerov6Addr;
+    v6Changed     = !mDNSSameIPv6Address(m->AdvertisedV6.ip.v6, v6);
     RouterChanged = !mDNSSameIPv4Address(m->Router.ip.v4,       router ? router->ip.v4 : zerov4Addr);
 
     if (v4addr && (v4Changed || RouterChanged))
@@ -4766,8 +4775,9 @@ mDNSexport void uDNS_CheckCurrentQuestio
             new = GetServerForQuestion(m, q);
             if (new)
             {
+		mDNSIPPort zp = zeroIPPort;
                 LogInfo("uDNS_checkCurrentQuestion: Retrying question %p %##s (%s) DNS Server %#a:%d ThisQInterval %d",
-                        q, q->qname.c, DNSTypeName(q->qtype), new ? &new->addr : mDNSNULL, mDNSVal16(new ? new->port : zeroIPPort), q->ThisQInterval);
+                        q, q->qname.c, DNSTypeName(q->qtype), new ? &new->addr : mDNSNULL, mDNSVal16(new? new->port : zp), q->ThisQInterval);
                 DNSServerChangeForQuestion(m, q, new);
             }
             for (qptr = q->next ; qptr; qptr = qptr->next)
@@ -4813,9 +4823,10 @@ mDNSexport void uDNS_CheckCurrentQuestio
                 }
                 else
                 {
+		    mDNSIPPort zp = zeroIPPort;
                     debugf("uDNS_CheckCurrentQuestion sending %p %##s (%s) %#a:%d UnansweredQueries %d",
                            q, q->qname.c, DNSTypeName(q->qtype),
-                           q->qDNSServer ? &q->qDNSServer->addr : mDNSNULL, mDNSVal16(q->qDNSServer ? q->qDNSServer->port : zeroIPPort), q->unansweredQueries);
+                           q->qDNSServer ? &q->qDNSServer->addr : mDNSNULL, mDNSVal16(q->qDNSServer ? q->qDNSServer->port : zp), q->unansweredQueries);
                     if (!q->LocalSocket)
                     {
                         q->LocalSocket = mDNSPlatformUDPSocket(m, zeroIPPort);
@@ -4910,9 +4921,12 @@ mDNSexport void uDNS_CheckCurrentQuestio
                     q->qDNSServer = GetServerForQuestion(m, q);
                     for (qptr = q->next ; qptr; qptr = qptr->next)
                         if (qptr->DuplicateOf == q) { qptr->validDNSServers = q->validDNSServers; qptr->qDNSServer = q->qDNSServer; }
-                    LogInfo("uDNS_checkCurrentQuestion: Tried all DNS servers, retry question %p SuppressUnusable %d %##s (%s) with DNS Server %#a:%d after 60 seconds, ThisQInterval %d",
+		    {
+			mDNSIPPort zp = zeroIPPort;
+                        LogInfo("uDNS_checkCurrentQuestion: Tried all DNS servers, retry question %p SuppressUnusable %d %##s (%s) with DNS Server %#a:%d after 60 seconds, ThisQInterval %d",
                             q, q->SuppressUnusable, q->qname.c, DNSTypeName(q->qtype),
-                            q->qDNSServer ? &q->qDNSServer->addr : mDNSNULL, mDNSVal16(q->qDNSServer ? q->qDNSServer->port : zeroIPPort), q->ThisQInterval);
+                            q->qDNSServer ? &q->qDNSServer->addr : mDNSNULL, mDNSVal16(q->qDNSServer ? q->qDNSServer->port : zp), q->ThisQInterval);
+		    }
                 }
             }
             else
@@ -5010,7 +5024,7 @@ mDNSexport void CheckNATMappings(mDNS *m
                     cur->retryInterval = NATMAP_INIT_RETRY;
                 }
 
-                uDNS_SendNATMsg(m, cur, mDNStrue); // Will also do UPnP discovery for us, if necessary
+                (void)uDNS_SendNATMsg(m, cur, mDNStrue); // Will also do UPnP discovery for us, if necessary
 
                 if (cur->ExpiryTime)                        // If have active mapping then set next renewal time halfway to expiry
                     NATSetNextRenewalTime(m, cur);
@@ -5047,8 +5061,14 @@ mDNSexport void CheckNATMappings(mDNS *m
         if (!mDNSIPv4AddressIsZero(EffectiveAddress) || cur->retryInterval > NATMAP_INIT_RETRY * 8)
         {
             const mStatus EffectiveResult = cur->NewResult ? cur->NewResult : mDNSv4AddrIsRFC1918(&EffectiveAddress) ? mStatus_DoubleNAT : mStatus_NoError;
-            const mDNSIPPort ExternalPort = HaveRoutable ? cur->IntPort :
-                                            !mDNSIPv4AddressIsZero(EffectiveAddress) && cur->ExpiryTime ? cur->RequestedPort : zeroIPPort;
+	    mDNSIPPort ExternalPort;
+
+	    if (HaveRoutable)
+		ExternalPort = cur->IntPort;
+	    else if (!mDNSIPv4AddressIsZero(EffectiveAddress) && cur->ExpiryTime)
+		ExternalPort = cur->RequestedPort;
+	    else
+		ExternalPort = zeroIPPort;
 
             if (!cur->Protocol || HaveRoutable || cur->ExpiryTime || cur->retryInterval > NATMAP_INIT_RETRY * 8)
             {
